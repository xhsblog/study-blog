{"data":{"site":{"siteMetadata":{"title":"xiaohesong's Blog","author":"xiaohesong"}},"markdownRemark":{"id":"194a607d-24de-574b-8e90-53f9c997d3cc","excerpt":"本文摘自 react学习集合 本节是  stack reconciler 程序的实现说明的集合。 本文有一定的技术含量，要对React公共API以及它如何分为核心，渲染器和协调(和解，reconciler)程序有很深的理解。如果你对React代码库不是很熟悉，请首先 阅读代码库概述 。 它还假设你了解React…","html":"<blockquote>\n<p>本文摘自<a href=\"https://github.com/xiaohesong/TIL/tree/master/front-end/react\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react学习集合</a></p>\n</blockquote>\n<blockquote>\n<p>本节是 <a href=\"https://reactjs.org/docs/codebase-overview.html#stack-reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">stack reconciler</a>程序的实现说明的集合。</p>\n</blockquote>\n<p>本文有一定的技术含量，要对React公共API以及它如何分为核心，渲染器和协调(和解，reconciler)程序有很深的理解。如果你对React代码库不是很熟悉，请首先<a href=\"https://github.com/xiaohesong/TIL/blob/master/front-end/react/codebase-overview.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">阅读代码库概述</a>。</p>\n<p>它还假设你了解React组件，它们的<a href=\"https://github.com/xiaohesong/TIL/blob/master/front-end/react/component-element-instance.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">实例和元素之间的差异</a>。</p>\n<p><code class=\"language-text\">stack reconciler</code>用于15版本和早期. 它的代码在 <a href=\"https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">src/renderers/shared/stack/reconciler</a>.</p>\n<h3 id=\"视频：从头开始构建react\"><a href=\"#%E8%A7%86%E9%A2%91%EF%BC%9A%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAreact\" aria-label=\"视频：从头开始构建react permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>视频：从头开始构建React</h3>\n<p><a href=\"https://twitter.com/zpao\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Paul O’Shannessy</a>谈到了从头开始构建react，这在很大程度上启发了这个文档。</p>\n<p>本文档和他的演讲都是对实际代码库的简化，因此你可以通过熟悉它们来获得更好的理解。</p>\n<h3 id=\"概述\"><a href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"概述 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>概述</h3>\n<p>reconciler(协调，调解)本身不存在公共的API。像React DOM和React Native这样的<a href=\"https://reactjs.org/docs/codebase-overview.html#stack-renderers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">渲染器</a>使用它根据用户编写的React组件有效地更新用户界面。</p>\n<h3 id=\"挂载mounting作为递归过程\"><a href=\"#%E6%8C%82%E8%BD%BDmounting%E4%BD%9C%E4%B8%BA%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B\" aria-label=\"挂载mounting作为递归过程 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>挂载(mounting)作为递归过程</h3>\n<p>让我们考虑第一次挂载组件:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>React DOM会将<code class=\"language-text\">&lt;App /&gt;</code>传递给调节器(reconciler)。请记住，<code class=\"language-text\">&lt;App /&gt;</code>是一个React元素，即对要呈现的内容的描述。你可以将其视为普通对象(笔者：不了解的可以查看<a href=\"https://github.com/xiaohesong/TIL/blob/master/front-end/react/component-element-instance.md#top-down-reconciliation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这篇文章</a>)：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// { type: App, props: {} }</span></code></pre></div>\n<p>调解器会检查这个<code class=\"language-text\">App</code>是类还是函数(对于这个得实现可以查看<a href=\"https://github.com/xiaohesong/TIL/blob/master/front-end/react/overreact/how-to-known-component-is-func-or-class.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">如何知道是函数还是类</a>这篇文章)。</p>\n<p>如果<code class=\"language-text\">App</code>是一个函数，则调解器将调用<code class=\"language-text\">App(props)</code>来获取渲染元素。</p>\n<p>如果<code class=\"language-text\">App</code>是一个类，那么调解器会通过<code class=\"language-text\">new App(props)</code>去实例化<code class=\"language-text\">App</code>，调用<code class=\"language-text\">componentWillMount</code>生命周期方法，然后调用<code class=\"language-text\">render</code>方法来获取渲染的元素。</p>\n<p>无论哪种方式，调解器都将得知<code class=\"language-text\">App</code>“渲染到”的元素。</p>\n<p>这个过程是递归的。<code class=\"language-text\">App</code>可能会渲染<code class=\"language-text\">&lt;Greeting /&gt;</code>,<code class=\"language-text\">&lt;Greeting /&gt;</code>可能会渲染<code class=\"language-text\">&lt;Button /&gt;</code>,一直这样。调解器将在了解每个组件呈现的内容时以递归方式“向下钻取”用户定义的组件。</p>\n<p>可以将此过程想象为伪代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// React.Component下面的类有这个标签\t</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">Boolean</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token function\">Boolean</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 这个函数接受一个React元素 (例如 &lt;App />)</span>\n<span class=\"token comment\">// 并且返回一个已经挂载了树的DOM或原生节点</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> props <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 我们将确定渲染元素的类型</span>\n  <span class=\"token comment\">// 函数就直接调用</span>\n  <span class=\"token comment\">// 类就实例化后调用render().</span>\n  <span class=\"token keyword\">var</span> renderedElement<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 类组件</span>\n    <span class=\"token keyword\">var</span> publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 设置props</span>\n    publicInstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 必要时调用生命周期方法</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>publicInstance<span class=\"token punctuation\">.</span>componentWillMount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 通过调用render()获得渲染的元素</span>\n    renderedElement <span class=\"token operator\">=</span> publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 函数组件</span>\n    renderedElement <span class=\"token operator\">=</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 这个过程是递归的 因为一个组件可能返回的元素的类型是另外一个组件</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>renderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n  <span class=\"token comment\">// 注意：这个实现是不完整的，并且会无限的重复下去</span>\n  <span class=\"token comment\">// 它只处理&lt;App/>或&lt;Button/>等元素。</span>\n  <span class=\"token comment\">// 它还没有处理像&lt;div/>或&lt;p/>这样的元素。</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> rootEl <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrootEl<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<p><strong>注意：</strong> 这真的仅仅只是一个伪代码，它与真实的实现并不相似。它还会导致堆栈溢出，因为我们还没有讨论何时停止递归。</p>\n</blockquote>\n<p>让我们回顾一下上面例子中的一些关键想法：</p>\n<ul>\n<li>React的elements只是一个纯对象，用来描述组件的类型(如：<code class=\"language-text\">App</code>)和他的props.</li>\n<li>用户定义的组件(如：<code class=\"language-text\">App</code>)可以是函数或者类，但是他们都会渲染这些元素。</li>\n<li>“Mounting”是一个递归过程，它在给定顶级React元素(例如<code class=\"language-text\">&lt;App /&gt;</code>)的情况下创建DOM或Native树。</li>\n</ul>\n<h3 id=\"mounting计算机host元素\"><a href=\"#mounting%E8%AE%A1%E7%AE%97%E6%9C%BAhost%E5%85%83%E7%B4%A0\" aria-label=\"mounting计算机host元素 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting计算机(Host)元素</h3>\n<p>如果我们没有在屏幕上呈现某些内容，则此过程将毫无用处。</p>\n<p>除了用户定义的（“复合”）组件之外，React元素还可以表示特定于平台的（“计算机”）组件。例如，<code class=\"language-text\">Button</code>可能会从其render方法返回<code class=\"language-text\">&lt;div /&gt;</code>。</p>\n<p>如果element的<code class=\"language-text\">type</code>属性是一个字符串，我们认为正在处理一个计算机元素：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// { type: 'div', props: {} }</span></code></pre></div>\n<p>没有与计算机元素关联的用户定义代码。</p>\n<p>当协调程序(调解器)遇到这些计算机元素时，它会让渲染器(renderer)负责mounting它。例如，React DOM将创建一个DOM节点。</p>\n<p>如果计算机元素具有子节点，则协调器以与上述相同的算法递归地mounts它们。子节点是否是计算机元素(<code class=\"language-text\">&lt;div&gt;&lt;hr /&gt;&lt;/div&gt;</code>)或用户合成的组件(<code class=\"language-text\">&lt;div&gt;&lt;Button /&gt;&lt;/div&gt;</code>),都没有关系，都会去让渲染器去负责mounting它。</p>\n<p>由子组件生成的DOM节点将附加到父DOM节点，并且将递归地组装完整的DOM结构。</p>\n<blockquote>\n<p><strong>注意:</strong> 调解器本身与DOM无关。mounting(安装)的确切结果（有时在源代码中称为“mount image”）取决于渲染器，可以是DOM节点（React DOM），字符串（React DOM Server）或表示原生视图（React Native）。</p>\n</blockquote>\n<p>如果我们要扩展代码来处理计算机元素，它将如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 继承自 React.Component 类有一个标签 isReactComponent</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">Boolean</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token function\">Boolean</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 这个函数只处理复合的元素</span>\n<span class=\"token comment\">// 比如像是&lt;App />, &lt;Button />这些，但不是&lt;div />这些</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountComposite</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> props <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> renderedElement<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 组件是类的情况，就去实例化他</span>\n    <span class=\"token keyword\">var</span> publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 设置props</span>\n    publicInstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 必要的时候调用生命周期方法</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>publicInstance<span class=\"token punctuation\">.</span>componentWillMount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    renderedElement <span class=\"token operator\">=</span> publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 组件是个函数</span>\n    renderedElement <span class=\"token operator\">=</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 这是递归的</span>\n  <span class=\"token comment\">// 但当元素是宿主（例如&lt;div/>）而不是复合（例如&lt;App/>）时，我们将最终完成递归：</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>renderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 这个函数仅仅处理计算机元素</span>\n<span class=\"token comment\">// 例如它处理&lt;div />和&lt;p />这些，但不处理&lt;App /></span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountHost</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> props <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> children <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    children <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>children<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  children <span class=\"token operator\">=</span> children<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>Boolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    \n  <span class=\"token comment\">// 这段代码不应该在协调器中。</span>\n  <span class=\"token comment\">// 不同的渲染器可能对节点进行不同的初始化。</span>\n  <span class=\"token comment\">// 例如，React Native将创建iOS或Android视图。</span>\n  <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>propName <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propName <span class=\"token operator\">!==</span> <span class=\"token string\">'children'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      node<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 安装子元素</span>\n  children<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>childElement <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 子元素可能是计算机元素(比如&lt;div />)，也有可能是一个合成组件(比如&lt;Button />)</span>\n    <span class=\"token comment\">// 我们都会递归挂载安装</span>\n    <span class=\"token keyword\">var</span> childNode <span class=\"token operator\">=</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>childElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 下面这个也是一个特定于平台的</span>\n    <span class=\"token comment\">// 它会根据不同的渲染器来处理，这里只是一个假设他是一个dom渲染器</span>\n    node<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 返回作为安装结果的DOM节点</span>\n  <span class=\"token comment\">// 这也是递归的结束的地方</span>\n  <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 用户定义的组件(合成的组件)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">mountComposite</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 计算机组件(例如: &lt;div />)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">mountHost</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> rootEl <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrootEl<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这是有效的，但仍远未达到协调者的实际运行方式。关键的缺失部分是对更新的支持。</p>\n<h3 id=\"介绍内部实例\"><a href=\"#%E4%BB%8B%E7%BB%8D%E5%86%85%E9%83%A8%E5%AE%9E%E4%BE%8B\" aria-label=\"介绍内部实例 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>介绍内部实例</h3>\n<p>react的关键特点是你可以重新渲染所有东西，它不会重新创建DOM或重置状态。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 应该重用现有的DOM:</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但是，我们上面的实现只知道如何挂载初始树。它无法对其执行更新，因为它不存储所有必需的信息，例如所有<code class=\"language-text\">publicInstance</code>s，或哪些DOM<code class=\"language-text\">节点</code>对应于哪些组件。</p>\n<p>堆栈协调器代码库通过使<code class=\"language-text\">mount</code>函数成为一个类上面的方法来解决这个问题。但是这种方法存在一些缺点，我们在正在进行的<a href=\"https://reactjs.org/docs/codebase-overview.html#fiber-reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">协调重写任务中</a>正朝着相反的方向去发展(笔者：目前fiber已经出来了)。<strong>不过</strong> 这就是它现在的运作方式。</p>\n<p>我们将创建两个类：<code class=\"language-text\">DOMComponent</code>和<code class=\"language-text\">CompositeComponent</code>，而不是单独的<code class=\"language-text\">mountHost</code>和<code class=\"language-text\">mountComposite</code>函数。</p>\n<p>两个类都有一个接受元素的构造函数，以及一个返回已安装节点的<code class=\"language-text\">mount()</code>方法。我们将用实例化类的工厂替换顶级<code class=\"language-text\">mount()</code>函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 用户定义的组件</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CompositeComponent</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 特定于平台的组件，如计算机组件(&lt;div />)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DOMComponent</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>首先，让我们考虑下<code class=\"language-text\">CompositeComponent</code>的实现:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CompositeComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedComponent <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getPublicInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 对于复合的组件，暴露类的实例</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicInstance<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> element <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> props <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">var</span> publicInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> renderedElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Component class</span>\n      publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// Set the props</span>\n      publicInstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// Call the lifecycle if necessary</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>publicInstance<span class=\"token punctuation\">.</span>componentWillMount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      renderedElement <span class=\"token operator\">=</span> publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Component function</span>\n      publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      renderedElement <span class=\"token operator\">=</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Save the public instance</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicInstance <span class=\"token operator\">=</span> publicInstance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 根据元素实例化子内部实例</span>\n    <span class=\"token comment\">// 他将是DOMComponent,例如&lt;div />, &lt;p /></span>\n    <span class=\"token comment\">// 或者是CompositeComponent,例如&lt;App />，&lt;Button /></span>\n    <span class=\"token keyword\">var</span> renderedComponent <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>renderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedComponent <span class=\"token operator\">=</span> renderedComponent<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Mount the rendered output</span>\n    <span class=\"token keyword\">return</span> renderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这与我们之前的<code class=\"language-text\">mountComposite()</code>实现没什么不同，但现在我们可以存储一些信息，例如<code class=\"language-text\">this.currentElement</code>,<code class=\"language-text\">this.renderedComponent</code>和<code class=\"language-text\">this.publicInstance</code>,在更新期间使用。</p>\n<p>请注意，<code class=\"language-text\">CompositeComponent</code>的实例与用户提供的<code class=\"language-text\">element.type</code>的实例不同。<code class=\"language-text\">CompositeComponent</code>是我们的协调程序的实现细节，永远不会向用户公开。用户定义的类是我们从<code class=\"language-text\">element.type</code>读取的，<code class=\"language-text\">CompositeComponent</code>会创建这个类的实例。</p>\n<p><strong>为避免混淆，我们将<code class=\"language-text\">CompositeComponent</code>和<code class=\"language-text\">DOMComponent</code>的实例叫做“内部实例”。</strong> 它们存在，因此我们可以将一些长期存在的数据与它们相关联。只有渲染器和调解器知道它们存在。</p>\n<p><strong>相反，我们将用户定义类的实例称为“公共实例(public instance)”。</strong> 公共实例是你在<code class=\"language-text\">render()</code>和组件其他的方法中看到的<code class=\"language-text\">this</code>.</p>\n<p>至于<code class=\"language-text\">mountHost()</code>方法，重构成了在<code class=\"language-text\">DOMComponent</code>类上的<code class=\"language-text\">mount()</code>方法，看起来像这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DOMComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedChildren <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getPublicInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// For DOM components, only expose the DOM node.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> element <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> props <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> children <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      children <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>children<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Create and save the node</span>\n    <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Set the attributes</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>propName <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propName <span class=\"token operator\">!==</span> <span class=\"token string\">'children'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 创建并保存包含的子元素</span>\n    <span class=\"token comment\">// 这些子元素，每个都可以是DOMComponent或CompositeComponent</span>\n    <span class=\"token comment\">// 这些匹配是依赖于元素类型的返回值(string或function)</span>\n    <span class=\"token keyword\">var</span> renderedChildren <span class=\"token operator\">=</span> children<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>instantiateComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedChildren <span class=\"token operator\">=</span> renderedChildren<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Collect DOM nodes they return on mount</span>\n    <span class=\"token keyword\">var</span> childNodes <span class=\"token operator\">=</span> renderedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>child <span class=\"token operator\">=></span> child<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    childNodes<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>childNode <span class=\"token operator\">=></span> node<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// DOM节点作为mount的节点返回</span>\n    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>与上面的相比，<code class=\"language-text\">mountHost()</code>重构之后的主要区别是现在将<code class=\"language-text\">this.node</code>和<code class=\"language-text\">this.renderedChildren</code>与内部DOM组件实例相关联。我们会用他来用于在后面做非破坏性的更新。</p>\n<p>因此，每个内部实例（复合或主机）现在都指向其子级内部实例。为了帮助可视化，如果函数<code class=\"language-text\">&lt;App&gt;</code>组件呈现<code class=\"language-text\">&lt;Button&gt;</code>类组件，而<code class=\"language-text\">Button</code>类呈现<code class=\"language-text\">&lt;div&gt;</code>，则内部实例树将如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>object CompositeComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  currentElement<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  publicInstance<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  renderedComponent<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object CompositeComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    currentElement<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span>Button <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    publicInstance<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object Button<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    renderedComponent<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object DOMComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n      currentElement<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span>div <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n      node<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object HTMLDivElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      renderedChildren<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在DOM中，你只能看到<code class=\"language-text\">&lt;div&gt;</code>。但是，内部实例树包含复合和主机内部实例。</p>\n<p>复合内部实例需要存储：</p>\n<ul>\n<li>当前元素</li>\n<li>公共实例，如果当前元素类型是个类</li>\n<li>单个呈现的内部实例。它可以是<code class=\"language-text\">DOMComponent</code>或<code class=\"language-text\">CompositeComponent</code>。</li>\n</ul>\n<p>计算机内部实例需要存储：</p>\n<ul>\n<li>当前元素</li>\n<li>DOM节点</li>\n<li>所有子级的内部实例，这些子级中的每一个都可以是<code class=\"language-text\">DOMComponent</code>或<code class=\"language-text\">CompositeComponent</code>。</li>\n</ul>\n<p>如果你正在努力想象如何在更复杂的应用程序中构建内部实例树，<a href=\"https://github.com/facebook/react-devtools\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React DevTools</a>可以给你一个近似的结果，因为它突显灰色的计算机实例，以及带紫色的复合实例：</p>\n<p><img src=\"https://reactjs.org/static/implementation-notes-tree-d96fec10d250eace9756f09543bf5d58-a6f54.png\"></p>\n<p>为了完成这个重构，我们将引入一个将完整树安装到容器节点的函数，就像<code class=\"language-text\">ReactDOM.render()</code>一样。他返回一个公共实例，也像<code class=\"language-text\">ReactDOM.render()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> containerNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 创建顶层的内部实例</span>\n  <span class=\"token keyword\">var</span> rootComponent <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 挂载顶层的组件到容器</span>\n  <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> rootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  containerNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 返回他提供的公共实例</span>\n  <span class=\"token keyword\">var</span> publicInstance <span class=\"token operator\">=</span> rootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">getPublicInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> publicInstance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> rootEl <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"卸载\"><a href=\"#%E5%8D%B8%E8%BD%BD\" aria-label=\"卸载 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>卸载</h3>\n<p>既然我们有内部实例来保存它们的子节点和DOM节点，那么我们就可以实现卸载。对于复合组件，卸载会调用生命周期方法并进行递归。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class CompositeComponent {\n\n  // ...\n\n  unmount() {\n    // 必要的时候调用生命周期方法\n    var publicInstance = this.publicInstance;\n    if (publicInstance) {\n      if (publicInstance.componentWillUnmount) {\n        publicInstance.componentWillUnmount();\n      }\n    }\n\n    // Unmount the single rendered component\n    var renderedComponent = this.renderedComponent;\n    renderedComponent.unmount();\n  }\n}</code></pre></div>\n<p>对于<code class=\"language-text\">DOMComponent</code>,卸载会告诉每个子节点进行卸载:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DOMComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 卸载所有的子级</span>\n    <span class=\"token keyword\">var</span> renderedChildren <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedChildren<span class=\"token punctuation\">;</span>\n    renderedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>child <span class=\"token operator\">=></span> child<span class=\"token punctuation\">.</span><span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>实际上，卸载DOM组件也会删除事件侦听器并清除一些缓存，但我们将跳过这些细节。</p>\n<p>我们现在可以添加一个名为<code class=\"language-text\">unmountTree(containerNode)</code>的新顶级函数，它类似于<code class=\"language-text\">ReactDOM.unmountComponentAtNode()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">unmountTree</span><span class=\"token punctuation\">(</span>containerNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 从DOM节点读取内部实例</span>\n  <span class=\"token comment\">// (目前这个不会正常工作， 我们将需要改变mountTree()方法去存储)</span>\n  <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> containerNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> rootComponent <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>_internalInstance<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 清除容器并且卸载树</span>\n  rootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  containerNode<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>为了让他工作，我们需要从DOM节点读取内部根实例。我们将修改<code class=\"language-text\">mountTree()</code>以将<code class=\"language-text\">_internalInstance</code>属性添加到DOM根节点。我们还将让<code class=\"language-text\">mountTree()</code>去销毁任何现有树，以便可以多次调用它：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> containerNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 销毁存在的树</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>containerNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">unmountTree</span><span class=\"token punctuation\">(</span>containerNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 创建顶层的内部实例</span>\n  <span class=\"token keyword\">var</span> rootComponent <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 挂载顶层的组件到容器</span>\n  <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> rootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  containerNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 保存内部实例的引用</span>\n  node<span class=\"token punctuation\">.</span>_internalInstance <span class=\"token operator\">=</span> rootComponent<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 返回他提供的公共实例</span>\n  <span class=\"token keyword\">var</span> publicInstance <span class=\"token operator\">=</span> rootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">getPublicInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> publicInstance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>现在，重复运行<code class=\"language-text\">unmountTree()</code>或运行<code class=\"language-text\">mountTree()</code>，删除旧树并在组件上运行<code class=\"language-text\">componentWillUnmount()</code>生命周期方法。</p>\n<h3 id=\"更新\"><a href=\"#%E6%9B%B4%E6%96%B0\" aria-label=\"更新 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>更新</h3>\n<p>在上一节中，我们实现了卸载。但是，如果每个prop更改导致卸载并安装整个树，则React就会显得不是很好用了。协调程序的目标是尽可能重用现有实例来保留DOM和状态：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> rootEl <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 应该重用存在的DOM</span>\n<span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>我们将使用另一种方法扩展我们的内部实例。除了<code class=\"language-text\">mount()</code>和<code class=\"language-text\">unmount()</code>之外，<code class=\"language-text\">DOMComponent</code>和<code class=\"language-text\">CompositeComponent</code>都将实现一个名为<code class=\"language-text\">receive(nextElement)</code>的新方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CompositeComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">DOMComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>它的任务是尽一切可能使组件（及其任何子组件）与nextElement提供的描述保持同步。</p>\n<p>这是经常被描述为“虚拟DOM区别”的部分，尽管真正发生的是我们递归地遍历内部树并让每个内部实例接收更新。</p>\n<h3 id=\"更新复合组件\"><a href=\"#%E6%9B%B4%E6%96%B0%E5%A4%8D%E5%90%88%E7%BB%84%E4%BB%B6\" aria-label=\"更新复合组件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>更新复合组件</h3>\n<p>当复合组件接收新元素时，我们运行<code class=\"language-text\">componentWillUpdate()</code>生命周期方法。</p>\n<p>然后我们使用新的props重新渲染组件，并获取下一个渲染元素：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CompositeComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> prevProps <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> publicInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevRenderedComponent <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedComponent<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevRenderedElement <span class=\"token operator\">=</span> prevRenderedComponent<span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 更新自有的元素</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement <span class=\"token operator\">=</span> nextElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> type <span class=\"token operator\">=</span> nextElement<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextProps <span class=\"token operator\">=</span> nextElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 弄清楚下一个render()的输出是什么</span>\n    <span class=\"token keyword\">var</span> nextRenderedElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClass</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 类组件</span>\n      <span class=\"token comment\">// 必要的时候调用生命周期</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>publicInstance<span class=\"token punctuation\">.</span>componentWillUpdate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">componentWillUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 更新props</span>\n      publicInstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> nextProps<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// Re-render</span>\n      nextRenderedElement <span class=\"token operator\">=</span> publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 函数式组件</span>\n      nextRenderedElement <span class=\"token operator\">=</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// ...</span></code></pre></div>\n<p>接下来，我们可以查看渲染元素的<code class=\"language-text\">type</code>。如果自上次渲染后<code class=\"language-text\">type</code>未更改，则下面的组件也可以在之前的基础上更新。</p>\n<p>例如，如果第一次返回<code class=\"language-text\">&lt;Button color =“red&quot;/&gt;</code>，第二次返回<code class=\"language-text\">&lt;Button color =“blue&quot;/&gt;</code>，我们可以告诉相应的内部实例<code class=\"language-text\">receive()</code>下一个元素：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">\t<span class=\"token comment\">// ...</span>\n\n    <span class=\"token comment\">// 如果渲染的元素类型没有改变,</span>\n    <span class=\"token comment\">// 重用现有的组件实例</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevRenderedElement<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> nextRenderedElement<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      prevRenderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextRenderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// ...</span></code></pre></div>\n<p>但是，如果下一个渲染元素的类型与先前渲染的元素不同，我们无法更新内部实例。<code class=\"language-text\">&lt;button /&gt;</code>不可能变成<code class=\"language-text\">&lt;input /&gt;</code>。</p>\n<p>相反，我们必须卸载现有的内部实例并挂载与呈现的元素类型相对应的新实例。例如，当先前呈现<code class=\"language-text\">&lt;button /&gt;</code>的组件呈现<code class=\"language-text\">&lt;input /&gt;</code>时，会发生这种情况：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">\t<span class=\"token comment\">// ...</span>\n\n\t<span class=\"token comment\">// 如果我们到达了这一点，那么我们就需要卸载之前挂载的组件</span>\n\t<span class=\"token comment\">// 挂载新的一个，并且交换他们的节点</span>\n\n\t<span class=\"token comment\">// 找到旧的节点，因为我们需要去替换他</span>\n    <span class=\"token keyword\">var</span> prevNode <span class=\"token operator\">=</span> prevRenderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 卸载旧的子级并且挂载新的子级</span>\n    prevRenderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextRenderedComponent <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>nextRenderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextNode <span class=\"token operator\">=</span> nextRenderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 替换对子级的引用</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedComponent <span class=\"token operator\">=</span> nextRenderedComponent<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 新的节点替换旧的</span>\n\t<span class=\"token comment\">// 记住：下面的代码是特定于平台的，理想情况下是在CompositeComponent之外的</span>\n    prevNode<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">.</span><span class=\"token function\">replaceChild</span><span class=\"token punctuation\">(</span>nextNode<span class=\"token punctuation\">,</span> prevNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>总而言之，当复合组件接收到新元素时，它可以将更新委托给其呈现的内部实例，或者卸载它并在其位置安装新的实例。</p>\n<p>在另一个条件下，组件将重新安装而不是接收元素，即元素的<code class=\"language-text\">key</code>已更改。我们不讨论本文档中的<code class=\"language-text\">key</code>处理，因为它为原本就很复杂的教程增加了更多的复杂性。</p>\n<p>请注意，我们需要将一个名为<code class=\"language-text\">getHostNode()</code>的方法添加到内部实例协定中，以便可以在更新期间找到特定于平台的节点并替换它。它的实现对于两个类都很简单：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CompositeComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 请求渲染的组件提供他</span>\n    <span class=\"token comment\">// 这将向下递归复合组件</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedComponent<span class=\"token punctuation\">.</span><span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">DOMComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"更换计算机组件\"><a href=\"#%E6%9B%B4%E6%8D%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E4%BB%B6\" aria-label=\"更换计算机组件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>更换计算机组件</h3>\n<p>计算机组件实现，例如<code class=\"language-text\">DOMComponent</code>, 以不同方式更新。当他们收到元素时，他们需要更新底层特定于平台的视图。在React DOM的情况下，这意味着更新DOM属性：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DOMComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevElement <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevProps <span class=\"token operator\">=</span> prevElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextProps <span class=\"token operator\">=</span> nextElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>    \n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentElement <span class=\"token operator\">=</span> nextElement<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 移除旧的属性</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>propName <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propName <span class=\"token operator\">!==</span> <span class=\"token string\">'children'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>nextProps<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 设置接下来的属性</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>propName <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propName <span class=\"token operator\">!==</span> <span class=\"token string\">'children'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span></code></pre></div>\n<p>然后，计算机组件需要更新他们的子组件。与复合组件不同，它们可能包含多个子组件。</p>\n<p>在这个简化的示例中，我们使用内部实例数组并对其进行迭代，根据接收的类型是否与之前的类型匹配来更新或替换内部实例。除了插入和删除之外，真正的协调程序还会使用元素的键跟踪移动，但我们将省略此逻辑。</p>\n<p>我们在列表中收集子级的DOM操作，以便批量执行它们：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">\t<span class=\"token comment\">// ...</span>\n\n    <span class=\"token comment\">// 这个是React elements数组</span>\n    <span class=\"token keyword\">var</span> prevChildren <span class=\"token operator\">=</span> prevProps<span class=\"token punctuation\">.</span>children <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>prevChildren<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      prevChildren <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>prevChildren<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">var</span> nextChildren <span class=\"token operator\">=</span> nextProps<span class=\"token punctuation\">.</span>children <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>nextChildren<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      nextChildren <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>nextChildren<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 这是内部实例的数组:</span>\n    <span class=\"token keyword\">var</span> prevRenderedChildren <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedChildren<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextRenderedChildren <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 当我们迭代子级的时候，我们将会添加操作到数组</span>\n    <span class=\"token keyword\">var</span> operationQueue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">//注意：下面的部分非常简单！</span>\n\t<span class=\"token comment\">//它的存在只是为了说明整个流程，而不是细节。</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nextChildren<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 尝试获取此子级的现有内部实例</span>\n      <span class=\"token keyword\">var</span> prevChild <span class=\"token operator\">=</span> prevRenderedChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 如果这个索引下不存在内部实例，那就把子级被追加到后面。</span>\n      <span class=\"token comment\">// 创建一个新的内部实例，挂载他并使用他的节点</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>prevChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> nextChild <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>nextChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> nextChild<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 记录我们需要追加的节点</span>\n        operationQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token punctuation\">:</span> <span class=\"token string\">'ADD'</span><span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        nextRenderedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>nextChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// 我们可以只更新元素类型匹配的实例(下面是元素类型相同)</span>\n      <span class=\"token comment\">// 例如 &lt;Button size='small' />可以被更新成&lt;Button size='large' /></span>\n      <span class=\"token comment\">// 但是不可以更新成&lt;App />(即元素类型不匹配)</span>\n      <span class=\"token keyword\">var</span> canUpdate <span class=\"token operator\">=</span> prevChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> nextChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 如果不能更新这个存在的实例，那么我们必须移除他</span>\n      <span class=\"token comment\">// 并且挂载一个新的去代替他</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>canUpdate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> prevNode <span class=\"token operator\">=</span> prevChild<span class=\"token punctuation\">.</span><span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        prevChild<span class=\"token punctuation\">.</span><span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">var</span> nextChild <span class=\"token operator\">=</span> <span class=\"token function\">instantiateComponent</span><span class=\"token punctuation\">(</span>nextChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> nextNode <span class=\"token operator\">=</span> nextChild<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 记录我们需要交换的节点</span>\n        operationQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token punctuation\">:</span> <span class=\"token string\">'REPLACE'</span><span class=\"token punctuation\">,</span> prevNode<span class=\"token punctuation\">,</span> nextNode<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        nextRenderedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>nextChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// 如果我们可以更新一个存在的内部实例</span>\n      <span class=\"token comment\">// 只需要让他接收下一个元素并且处理他自己的更新</span>\n      prevChild<span class=\"token punctuation\">.</span><span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>nextChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      nextRenderedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>prevChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// 最后卸载不存在的元素的子级</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> j <span class=\"token operator\">=</span> nextChildren<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> prevChildren<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> prevChild <span class=\"token operator\">=</span> prevRenderedChildren<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> prevChild<span class=\"token punctuation\">.</span><span class=\"token function\">getHostNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      prevChild<span class=\"token punctuation\">.</span><span class=\"token function\">unmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 记录我们需要移除的节点</span>\n      operationQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token punctuation\">:</span> <span class=\"token string\">'REMOVE'</span><span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// 将渲染的子级列表指到更新的版本里</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>renderedChildren <span class=\"token operator\">=</span> nextRenderedChildren<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span></code></pre></div>\n<p>作为最后一步，我们执行DOM操作。同样，真正的协调代码更复杂，因为它也处理移动：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">\t<span class=\"token comment\">// ...</span>\n\n    <span class=\"token comment\">// Process the operation queue.</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>operationQueue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> operation <span class=\"token operator\">=</span> operationQueue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'ADD'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'REPLACE'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">.</span><span class=\"token function\">replaceChild</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">.</span>nextNode<span class=\"token punctuation\">,</span> operation<span class=\"token punctuation\">.</span>prevNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'REMOVE'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这就是更新计算机组件(DOMComponent)</p>\n<h3 id=\"顶层更新\"><a href=\"#%E9%A1%B6%E5%B1%82%E6%9B%B4%E6%96%B0\" aria-label=\"顶层更新 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>顶层更新</h3>\n<p>现在<code class=\"language-text\">CompositeComponent</code>和<code class=\"language-text\">DOMComponent</code>都实现了<code class=\"language-text\">receive(nextElement)</code>方法，我们可以更改顶级<code class=\"language-text\">mountTree()</code>函数，以便在元素类型与上次相同时使用它：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> containerNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 检查存在的树</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>containerNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> prevNode <span class=\"token operator\">=</span> containerNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevRootComponent <span class=\"token operator\">=</span> prevNode<span class=\"token punctuation\">.</span>_internalInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> prevElement <span class=\"token operator\">=</span> prevRootComponent<span class=\"token punctuation\">.</span>currentElement<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 如果我们可以，复用存在的根组件</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevElement<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      prevRootComponent<span class=\"token punctuation\">.</span><span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 其他的情况卸载存在的树</span>\n    <span class=\"token function\">unmountTree</span><span class=\"token punctuation\">(</span>containerNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>现在以相同的类型调用<code class=\"language-text\">mountTree()</code>两次，不会有破坏性的更新了:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> rootEl <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Reuses the existing DOM:</span>\n<span class=\"token function\">mountTree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> rootEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这些是React内部工作原理的基础知识。</p>\n<h3 id=\"我们遗漏了什么\"><a href=\"#%E6%88%91%E4%BB%AC%E9%81%97%E6%BC%8F%E4%BA%86%E4%BB%80%E4%B9%88\" aria-label=\"我们遗漏了什么 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>我们遗漏了什么</h3>\n<p>与真实代码库相比，本文档得到了简化。我们没有解决几个重要方面：</p>\n<ul>\n<li>组件可以呈现<code class=\"language-text\">null</code>，并且协调程序可以处理数组中的“空”并呈现输出。</li>\n<li>协调程序还从元素中读取<code class=\"language-text\">key</code>，并使用它来确定哪个内部实例对应于数组中的哪个元素。实际React实现中的大部分复杂性与此相关。</li>\n<li>除了复合和计算机内部实例类之外，还有“text”和“empty”组件的类。它们代表文本节点和通过呈现<code class=\"language-text\">null</code>获得的“空槽”。</li>\n<li>渲染器使用<a href=\"https://reactjs.org/docs/codebase-overview.html#dynamic-injection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">注入</a>将计算机内部类传递给协调程序。例如，<code class=\"language-text\">React DOM</code>告诉协调程序使用<code class=\"language-text\">ReactDOMComponent</code>作为计算机内部实例实现。</li>\n<li>更新子项列表的逻辑被提取到名为<code class=\"language-text\">ReactMultiChild</code>的<code class=\"language-text\">mixin</code>中，它由<code class=\"language-text\">React DOM</code>和<code class=\"language-text\">React Native</code>中的计算机内部实例类实现使用。</li>\n<li>协调程序还在复合组件中实现对<code class=\"language-text\">setState()</code>的支持。事件处理程序内的多个更新将被批处理为单个更新。</li>\n<li>协调器还负责将引用附加和分离到复合组件和计算机节点。</li>\n<li>在DOM准备好之后调用的生命周期方法（例如<code class=\"language-text\">componentDidMount()</code>和<code class=\"language-text\">componentDidUpdate()</code>）将被收集到“回调队列”中并在单个批处理中执行。</li>\n<li>React将有关当前更新的信息放入名为“transaction”的内部对象中。transaction对于跟踪待处理生命周期方法的队列、警告当前DOM的嵌套以及特定更新的“全局”其他任何内容都很有用。事务还确保React在更新后“清理所有内容”。例如，<code class=\"language-text\">React DOM</code>提供的事务类在任何更新后恢复输入选择。</li>\n</ul>\n<h3 id=\"进入代码\"><a href=\"#%E8%BF%9B%E5%85%A5%E4%BB%A3%E7%A0%81\" aria-label=\"进入代码 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>进入代码</h3>\n<ul>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/client/ReactMount.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ReactMount</a>是本教程中的<code class=\"language-text\">mountTree()</code>和<code class=\"language-text\">unmountTree()</code>之类的代码。他负责安装和卸载顶层的组件。<a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeMount.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactNativeMount</code></a>是React Native的模拟。</li>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/shared/ReactDOMComponent.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactDOMComponent</code></a>等同于本教程中的<code class=\"language-text\">DOMComponent</code>。它实现了React DOM渲染器的计算机组件类。<a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeBaseComponent.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactNativeBaseComponent</code></a>是对React Native的模拟。</li>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactCompositeComponent</code></a>是等同于本教程中的<code class=\"language-text\">CompositeComponent</code>。他处理用户自定义的组件并维护状态。</li>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/instantiateReactComponent.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">instantiateReactComponent</code></a>用于选择要为元素构造的内部实例类。它等同于本教程中的<code class=\"language-text\">instantiateComponent()</code>。</li>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactReconciler.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactReconciler</code></a>里是<code class=\"language-text\">mountComponent()</code>,<code class=\"language-text\">receiveComponent()</code>, <code class=\"language-text\">unmountComponent()</code>方法。它调用内部实例上的底层实现，但也包括一些由所有内部实例实现共享的代码。</li>\n<li><a href=\"https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactChildReconciler.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">ReactChildReconciler</code></a>实现独立于渲染器处理子级的插入，删除和移动的操作队列。</li>\n<li>由于遗留原因，<code class=\"language-text\">mount()</code>，<code class=\"language-text\">receive()</code>和<code class=\"language-text\">unmount()</code>在React代码库中实际上称为<code class=\"language-text\">mountComponent()</code>，<code class=\"language-text\">receiveComponent()</code>和<code class=\"language-text\">unmountComponent()</code>，但它们接收元素。</li>\n<li>内部实例上的属性以下划线开头，例如<code class=\"language-text\">_currentElement</code>。它们被认为是整个代码库中的只读公共字段。</li>\n</ul>\n<h3 id=\"未来的发展方向\"><a href=\"#%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91\" aria-label=\"未来的发展方向 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>未来的发展方向</h3>\n<p>堆栈协调器(stack reconciler)具有固有的局限性，例如同步并且无法中断工作或将其拆分为块。<a href=\"https://reactjs.org/docs/codebase-overview.html#fiber-reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">新的 Fiber reconciler</a>正在进行中(笔：当然，大家都知道，目前已经完成了)，他们有<a href=\"https://github.com/acdlite/react-fiber-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">完全不同的架构</a>。在未来，我们打算用它替换堆栈协调程序，但目前它远非功能校验。</p>\n<h3 id=\"下一步\"><a href=\"#%E4%B8%8B%E4%B8%80%E6%AD%A5\" aria-label=\"下一步 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>下一步</h3>\n<p>阅读<a href=\"https://github.com/xiaohesong/TIL/blob/master/front-end/react/react%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">下一节</a>，了解我们用于React开发的指导原则。</p>\n<p>原文： <a href=\"https://reactjs.org/docs/implementation-notes.html#video-building-react-from-scratch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Implementation Notes</a></p>","frontmatter":{"title":"从代码实践潜入react内部","date":"January 06, 2019","description":"通过实现组件的挂载，卸载，更新来深入理解diff是如何执行的"}}},"pageContext":{"slug":"/implementation-react-notes/","previous":null,"next":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"编写可伸缩组件"}}}}